TRADE SYNC

1. Have the basic idea. 


    Web-based trade copier for OANDA Trade accounts. 

2. Create business rules. Write down exactly how the program should act. 
    a. Functional requirements (what the system does)

        The backend should manage user accounts. Users can manage Master and Child accounts. Using the OANDA API, child accounts will copy all trades taken on Master accounts.

    b. Non-functional requirements (performance, security, etc.)

        Use AVL trees to store User accounts (O(log(n)) search time), not sure how to store Master/Child Accounts.

    c. User stories/use cases

        The Trade Copier must work 24/7, the user's trades must be copied from the master account even if the Web app isn't open.

    d. System Constraints

        Must run on any web browser. 
        VPS contraints:
            CPU Cores: 1
            Memory: 4GB
            Disk Space: 50GB


3. Identify Objects that can be created from the business rules.
    a. Highlight nouns in business rules (potential Objects)

        User
        TradeAccount -> MasterAccount, ChildAccount
        Database -> AVL Tree 

    b. Identify relationships between Objects


    c. Create a basic UML class diagram
    
    d. Defind Object hierarchies

4. Plan Each Class's reponsibilites
    a. Use Single responsibility Principle (SRP)

    b. Define what each class:
        - Knows (Attributes)
        - Does (Methods)

    c. Identify collaborations between classes

    d. Document dependencies

5. Define Class Interfaces and clear method signatues

6. Create an implimentation plan:
    a. Start with Models.
        - Add validation and Helper methods
        - Write unit tests for models

    b. External Services
        - Create interface contracts
        - Implement mock services for testing
        - Add real service implementation
        - Add integration tests

    c. Business logic
        - Test-driven development approach
        - Integration testing strategies

7. Additional Features
    1. Catching Layer
        - Cache strategy
        - Cache invalidation rules
    2. Error Handling
        - Custom exceptions
        - Error recovery strategies
        - User feedback
    3. Logging
        - Structured logging
        - Log levels
        - Performance metrics
        - Monitoring strategy
    4. Configuration
        - Environment-based settings
        - Feature flags
        - Configuration management
    5. Security
        - Authentication/Authorization
        - Data validation
        - Security best practices
    6. Documentation
        - API documentation
        - User guides
        - Developer documentation

8. Quality Assurance
    a. Testing Strategy
        - Unit tests
        - Integration tests
        - End-to-end tests
    
    b. Code Quality
        - Code review process
        - Static code analysis
        - Performance testing
    
    c. Deployment Strategy
        - Deployment process
        - Rollback procedures
        - Monitoring setup